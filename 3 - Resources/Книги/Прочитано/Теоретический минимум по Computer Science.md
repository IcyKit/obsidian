---
Автор: Владстон Феррейра Фило
Обложка: https://cv4.litres.ru/pub/c/cover_max1500/34946144.jpg
Жанр: Программирование
Оценка: 4️⃣
---

# Теоретический минимум по Computer Science

## Идея
Оказавшись перед сложной задачей, поднимитесь над ее хитро-сплетениями и изложите все самое важное на бумаге.

### Блок схемы
Программисты часто пользуются блок-схемами для изображения вычислительных процессов на бумаге.

Чтобы другие могли понимать ваши блок-схемы, вы должны соблюдать следующие рекомендации:

- Записывайте состояния и инструкции внутри прямоугольников;
- Записывайте принятие решений, когда процесс может пойти различными путями, внутри ромбов;
- Никогда не объединяйте инструкции с принятием решений
- Соединяйте стрелкой каждый последующий шаг с предыдущим
- Отмечайте начало и конец процесса.

![Block|450](https://i.stack.imgur.com/p0ckg.png)

### Псевдокод
Так же, как блок-схемы, псевдокод выражает вычислительные процессы. Псевдокод - это код, удобный для нашего восприятия, но непонятный для машины.

```ts
function maxInt(a, b, c) 
	if A > B
		if A > C
			return A
		else
			return C
	else 
		if B > C
			return B
		else 
			return C 
```

В псевдокод можно вставлять даже разговорные фразы. Когда вы пишете псевдокод, дайте своей творческой мысли течь свободно - как при составлении блок-схем

## Стратегия
Прием многократного использования промежуточных результатов называется мемоизацией

## Данные
Связные списки предпочтительнее массивов, когда:
- Нужно, чтобы операции вставки и удаления выполнялись чрезвычайно быстро
- Не требуется произвольный доступ к данным
- Приходится вставлять или удалять элементы между других элементов
- Заранее не известно количество элементов (оно будет расти или уменьшится по ходу выполнения программы)

Массивы предпочтительнее связных списков, когда:
- Нужен произвольный доступ к данным
- Нужен очень быстрый доступ к элементам
- Число элементов не изменяется во время выполнения програм- мы, благодаря чему легко выделить непрерывное пространство памяти

### Дерево
Дерево (tree) использует элементы, которым для хранения объектов не нужно располагаться в физической памяти непрерывно. Деревья особенно удобны для иерархических данных, таких как каталоги с файлами или система субординации.

#### Двоичное дерево поиска
Двоичное дерево поиска (binary search tree) — это особый тип дерева, поиск в котором выполняется особенно эффективно. Узлы в двоичном дереве поиска могут иметь не более двух дочерних узлов. Кроме того, узлы располагаются согласно их значению/ключу. Дочерние узлы слева от родителя должны быть меньше него, а справа — больше.

![[binarytree1.png]]

#### Балансировка дерева
Если вставить в двоичное дерево поиска слишком много узлов, в итоге получится очень высокое дерево, где большинство узлов имеют всего один дочерний узел. Мы можем перестроить узлы в дереве так, что его высота уменьшится. Эта процедура вызывается балансировкой дерева. Идеально сбалансированное дерево имеет минимальную высоту.

![[binarytree2.png]]

### Граф
Граф аналогичен дереву. Разница состоит в том, что у него нет ни дочерних, ни родительских узлов (вершин) и, следователь но, нет корневого узла. Данные свободно организованы в виде узлов (вершин) и дуг (ребер) так, что любой узел может иметь произвольное число входящих и исходящих ребер.

### Хеш-таблица
Хеш-таблица — это структура данных, которая позволяет находить элементы за O(1). Поиск занимает постоянное время вне зависимости от того, ищете вы среди 10 млн элементов или всего среди 10.

## Алгоритмы
### Поиск в графах
Существует два типа поиска: 
1. Depth first search / DFS (Поиск в глубину)
2. Breadth first search / BFS (Поиск в ширину)

Алгоритмы DFS и BFS отличаются только способом хранения следующих исследуемых вершин: в одном случае это очередь (BFS), в другом — стек (DFS).

Алгоритм DFS более прост в реализации и использует меньше памяти. В BFS придется хранить всю границу процесса поиска.

Когда есть основания предполагать, что искомая вершина не находится многими уровнями ниже начальной, обычно имеет смысл заплатить более высокую стоимость BFS, потому что так вы, скорее всего, закончите поиск быстрее. Если нужно исследовать абсолютно все вершины графа, лучше придерживаться алгоритма DFS из-за его простой реализации и меньшего объема потребляемой памяти.

## Базы Данных
### Транзакции

Транзакция — список операций, которые должны быть выполнены атомарно. Атомарные операции выполняются одноэтапно: они не могут быть выполнены наполовину.

```sql
START TRANSACTION;
UPDATE vault SET balance = balance + 50 WHERE id=2; 
UPDATE vault SET balance = balance — 50 WHERE id=1; 
COMMIT;
```

## Программирование
### Лингвистика
Значение представляет информацию. Выражение производит значение. Ин- струкция использует значение, чтобы дать команду компьютеру.

### Парадигмы
#### Императивное программирование
Парадигма императивного программирования подразумевает создание списка конкретных команд, описывающих, что именно должен делать компьютер на каждом шаге. Яркий пример - Assembler

#### Декларативное программирование
Парадигма декларативного программирования позволяет объявить желаемый результат, не разбираясь с каждым отдельным шагом, ведущим к нему.

##### Функциональное программирование
В парадигме функционального программирования функции — это больше, чем просто процедуры. Они используются для объявления связи между двумя или более элементами, почти как математические уравнения.

Функции могут получать другие функции в аргументах и возвращать функции в виде результата. Функции, имеющие такие признаки, называются функциями высшего порядка.

Функции высшего порядка могут не только принимать функции на входе, но также порождать и возвращать новые функции. Они даже в состоянии замкнуть ссылку на значение в сгенерированную функцию. Это называется замыкание. Функция, имеющая замыкание, «помнит» окружение, в котором была создана, и может обращаться к заключенным в нем значениям. Замыкание — это функция, которая имеет доступ к некоторым переменным за пределами собственного контекста.

[[Книги]]