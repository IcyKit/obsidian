# useState

**useState** - хранит состояние чего либо в компоненте.

Аналог `this.setState` в классовом компоненте.

Для начала использования данного хука его нужно импортировать из React.

```tsx
import {React, useState} from 'react';
```

Чтобы инициализировать состояние, нужно использовать функцию, которую мы только что импортировали. Так как функция возвращает кортеж, т.е. мы знаем, что:

- Первый элемент всегда - состояние
- Второй элемент - функция для изменения этого состояния

_Состояние ни в коем случае нельзя менять напрямую, только через функцию возвращаемую из useState._

Поэтому импорт мы выполняем используя деструктуризацию массива.

```tsx
const [state, setState] = useState(0);
```

В переменную под первым индексом мы даем название нашей переменной, которую будем использовать в дальнейшем, а в переменную под вторым индексом (функцию) - **set + название нашей перменной.**

Аргумент функции `useState()` - наше начальное состояние объекта. Значение, которое будет иметь переменная `state` при первой загрузке страницы.

### Изменение состояния

Чтобы изменить состояние, нам нужно вызвать функцию, которую мы вытащили из массива и передать в ее аргумент новое значение состояния.

Вызывать функцию можно несколькими способами:

- Внутри отдельной функции

```tsx
function setAnotherValue() {
	setState(другое значение)
}
```

- Внутри верстки. Например в `onClick` в кнопке или `onInput` в input

```tsx
<button onClick={() => setState(другое значение)}>Кнопка</button>
```

### Управление состоянием через блок

Мы не можем управлять состоянием через блок `if else`. Это запрещено самим React. Он будет выдавать ошибку.

### Асинхронность функции

Если мы захотим в одной функции два раза обратиться и поменять один и тот-же `State`

```tsx
function increment() {
	setCounter(counter + 1);
	setCounter(counter + 1);
}
```

Так как функции выполняются параллельно друг другу, а не поочередно, то и обращаться они будут к одному и тому же состоянию.

Но, если мы передадим в `setCounter()` callbaсk функцию, то аргументом этой функции будет являться предыдущее состояние, оно приходит туда автоматически, это делает React.

И после этого, записи нашей функции будет такая:

```tsx
function increment() {
	setCounter((prevState) => {
		return prevState + 1;
	});
	
	setCounter((prevState) => {
		return prevState + 1;
	});
}
```

### Определения начального состояния функцией

Если мы захотим вычислить начальное значение состояния какой либо функцией и просто передадим ее как аргумент в `useState`, то после каждого изменения состояния счетчика, функция будет вызываться каждый раз, так как мы заново рендерим компонент.

Чтобы избежать этого, мы просто можем передавать в `useState` callback функцию.

```tsx
const [state, setState] = useState(() => {
	return someCalculations();
})
```

Теперь, если мы будем изменять состояние счетчика, то функция не будет вызываться заново.

### Создание состояния в виде объекта

У изменения состояния в видео объекта в классовом и функциональном компоненте есть различия. Когда мы изменяем поле объекта в классовом компоненте, то в итоге нам возвращается весь объект и его измененное поле.

Если мы изменим одно поле в функциональном компоненте, то и объект станет содержать в себе только это поле, поэтому предварительно, нужно развернуть все остальные ключи объекта

```tsx
const [state, setState] = useState({
	title: 'Счетчик',
	counter: 0,
})
```

```tsx
function updateState() {
	setState(prev => {
		...prev,
		title: 'Новое название'
	})
}
```

В такой функции мы разворачиваем все предыдущие свойства, добавляем и обновляем новые свойства.

### Полная структура приложения для примера

```tsx
function App() {
	const [counter, setCounter] = useState(0);

	function increment() {
		setCounter(counter + 1);
	}

	function decrement() {
		setCounter(counter - 1);
	}

	return (
		<div>
			<h1>Счетчик: {counter}</h1>
			<button onClick={() => increment}>Добавить</button>
			<button onClick={() => decrement}>Убрать</button>
		</div>)
}
```

Когда мы откроем страницу счетчика, после заголовка "Счетчик", мы увидим цифру 0, что соответствует нашему начальному состоянию.

На кнопки мы назначили функции, которые внутри себя выполняют функцию изменения состояния.

При нажатии на кнопку "Добавить", `counter` будет увеличиваться на единицу, а при нажатии на "Убрать", единица будет вычитаться.