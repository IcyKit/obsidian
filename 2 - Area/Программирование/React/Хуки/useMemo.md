# useMemo

**useMemo** - Возвращает мемоизированное значение. Позволяет закешировать значение или функцию и не запускать ее заново, пока не изменится состояние в массиве зависимостей.

Для начала использования данного хука его нужно импортировать из React.

```tsx
import {React, useMemo} from 'react';
```

Полность хук выглядит следующим образом:

```tsx
const memoize = useMemo(() => {
	return someFunction();
}, [state1]);
```

### Полная структура приложения для примера

```tsx
let complexCompute(num) {
	let i = 0;
	while (i < 100000000) i++;
	return num * 2;
}

function App() {
	const [number, setNumber] = useState(42);
	const [colored, setColored] = useState(false);

	const computed = useMemo(() => {
		complexCompute(number);
	}, [number]);

	const styles = {
		color: colored ? 'darkred' : 'black';
	}

	return (
		<div>
			<h1 style={styles}>Вычисляемое свойство: {computed}</h1>
			<button onClick={() => setNumber(prev => prev + 1)}>Добавить</button>
			<button onClick={() => setNumber(prev => prev - 1)}>Убрать</button>
			<button onClick={() => setColored(prev => !prev)}>Изменить цвет</button>
		</div>)
}
```

**Пояснение к коду**

Отображаемая в заголовке переменная, требует более 2 секунд чтобы вычислится и записаться. Так как функции вызываются каждый раз при перерисовки компонента, даже если мы будем прибавлять по одному через кнопки, это все равно будет происходить через две секунды.

Но, если мы захотим сменить цвет заголовка, то он все равно будет меняться больше двух секунд.

Чтобы избежать этого, нам нужно мемоизировать (кешировать) функцию по вычислению.

В таком случае, функция будет вызываться только при изменении массива зависимостей, в нашем случае, при изменении `number`.

Теперь, цвет заголовка меняется моментально.