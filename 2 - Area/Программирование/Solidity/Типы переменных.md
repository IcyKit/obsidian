# Типы переменных

Переменные объявляются **строгой типизацией**, нужно указывать какой тип будет хранить переменная

Переменные которые хранятся в контракте - хранятся в блокчейне (состояние), а те, которые хранятся в функции - хранятся в памяти (локальная)

## `uint` - Unsigned integer.

Целое число без запятых. Имеет размерности (может быть и без нее), всегда лучше выбирать 256, т.е. `uint256`

- Unsigned integers - не отрицательное число. Максимально допустимое число - 2 ** 8. `uint`
- Signed integers - может быть и отрицательное и положительное. Максимально допустимое число - 2 ** 7. `int`

## `bool` - Булевый тип.

Хранит true или false. Если не присвоить переменной никакого значения, значение по дефолту будет **false**;

`### &&, ||, ==, ≠,!localBool` - Оперторы сравнения

## `string` - Строка.

Чтобы указать что строка будет записываться в память, а не блокчейн - нужно указать после `string` - `memory`. Для аргументов функции тоже нужно указывать место хранения строки. Нет понятия длина строки.

## `address` - Адрес.

Такого типа данных нет в общецелевых языках, он есть только в Solidity. Содержит в себе адрес типа 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4. Чтобы через функцию, через метод `transfer` перевести деньги на другой адрес, адрес должен быть помечен как `payable`, чтобы это сделать есть два пути:

- В аргументе функции при указании адреса, после адреса добавить `payable`.
- Использовать приведение типов и в теле функции написать следующее:

```solidity
function transferTo(address targetAddr, uint amount) public {
        **address payable _to = payable(targetAddr);**
        _to.transfer(amount);
    }
```

## `mapping` - словарь (хэш-таблица)

вида ключ - значение.

Можно представить ввиде гардероба. Вы сдаете свою куртку и получаете номерок. Всякий раз, когда вы возвращаете этот номерок, вы немедленно получаете свою куртку. В гардеробе может быть много курток, но вы все равно получите свою куртку обратно.

Аналог в JS - Map (не метод массива).

Ключами могут быть **только**: числа, адреса, булевые значение, строки. Также как и у строки нет понятия длины.

## `enum` - набор структур или состояний. 

Записывается таким образом:

```solidity
enum Status = { Paid, Delivered, Received } 
// Мы говорим,
// что у создаваемой нами типа данных, 
// будет только 3 указанных состояния

// Дальше, можем использовать этот enum для создания переменных

Status public currentStatus;

// И после создания переменной, можем управлять ее статусом:

function pay() public {
	currentStatus = Status.Paid; //Пишем название enum, 
	// и через точку значение
}

function delivered() public {
	currentStatus = Status.Delivered;
}

// **НО!** currentStatus будет выдавать не название состояния,
// а индекс состояния в enum
```

## `Array` - массив. 

Определяется следующей командой:

`uint[10] public items;`

`uint` говорит о том, какой тип данных будет содержать массив. Он **не может** содержать несколько типов данных, только один. Цифры в скобках, т.е. `[10]` говорят о размерности массива, т.е. сколько он может вместить в себя элементов. Для незаполненых мест в массиве, если он состоит из чисел, значение будет 0, если он состоит из строк, то будут пустые строки.

Массивы могут быть вложенными:

`uint[3][2] public items;`

В таком случае, определение массива идет с конца. Т.е. в массиве `items`, будет 2 массива, внутри которых будет по 3 места для чисел.

Также есть массивы с динамической длинной, при его создании, нужно оставить квадратные скобки пустыми. В этот массив можно добавить значение методом `push()`.

У массива есть свойство `.length`, которое показывает его длину.

Массив всегда хранится в блокчейне, но его можно сделать временным внутри функции. Тогда его запись будет выглядеть вот так:

```solidity
function sampleMemory() public view returns(uint[] memory) {
	uint[] memory tempArray = new uint[](10)
	tempArray[0] = 1;
	return tempArray;
}
```

В такой странной записи, в круглых скобках мы указываем размерность массива.

## `bytes` - байтовый массив. 

Записывается следующим образом:

`bytes1 public myVar;`

bytes1 говорит о том, что переменная myVar имеет размерность ровно 1 байт, т.е. 8 бит, информация в нем будет храниться в последовательности байтов

Размерность может меняться от 1 до 32 байт. Так как 32 * 8 = 256, т.е. максимальное значение для чисел.

Мы можем даже хранить в переменной строки, тогда она будет храниться в последовательности байтов.

Также байтовые массивы можно делать с динамической размерностью, тогда указывать числа в типе данных не надо.

Если мы с помощью функции вернем длину байтового массива, то мы получим его размерность. По индексу мы можем возвращать закодированный байт строки.

## `struct` - нечто похожее на класс в JS.

Записывается следующим образом:

```solidity
struct Payment {
	uint amount;
	uint timestamp;
	address from;
	string message;
}
```