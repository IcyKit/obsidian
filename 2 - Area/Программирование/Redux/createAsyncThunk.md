# createAsyncThunk

- [Документация](https://redux-toolkit.js.org/api/createAsyncThunk)
- [Видео с объяснением и использованием](https://www.youtube.com/watch?v=azf3uk4zOew)

Данная **АСИНХРОННАЯ** функция помогает нам вынести бизнес логику, чтобы мы могли использовать ее на всех страницах, а не повторять код на нескольких.

`createAsyncThunk` чаще используется, если нам нужно сделать запрос и сохранить результат в  этом же `slice`.

Асинхронная функция создается в том же `slice`, что и `state` с которым мы будем работать, но не внутри самого `slice`.  
Хороший тон - создавать такие функции вверху файла.  
Такие функции **не должны** содержать _side effect_. То есть они не должны влиять ни на что, кроме самого `slice`.

```jsx
export const имя_функции = createAsyncThunk(
	'имя_слайса/любое_имя_для_этой_функции', 
	async (аргумент, thunkApi) => {  
		let результат_запроса = //...
		return результат_запроса
	}  
)
```

`createAsyncThunk` принимает в себя два аргумента:

1. Имя функции. Имя функции также как и имя `slice` не дает нам ничего, это нужно для операций внутри `Redux Toolkit`.
2. Сама асинхронная функция. В первый аргумент приходит то, что мы будем передавать в `action.payload`, а во второй [[ThunkAPI]].

Если мы делаем в функции запрос, а эта функция используется в 99% случаев, если мы хотим сделать запрос, то она обязательно должна возвращать полученную информацию от запроса через `return`.

У такой функции, как и у промиса будет три состояния:

1. `pending` - запрос отправлен.
2. `fulfilled` - запрос прошел успешно и нам пришел ответ.
3. `rejected` - ошибка запроса, нам приходит ошибка с сервера.  
    И в зависимости от статуса функции, мы можем делать различный код. Для этого, нам нужно добавить новое поле в объект `slice`.

Поле должно называться `extraReducers` и это поле должно быть объектом.  
Теперь мы можем передавать деструкторизацией массива - имя поля и его состояние, а затем функцию, которая будет исполняться, когда указанная функция будет находиться в указанном состоянии. Функция принимает в себя два аргумента:

1. `state` - состояние этого `slice`
2. `action` - объект, у которого есть поле `payload` и в него приходят аргументы, которые мы передали при вызове.  
    Пример приведен на приложении для заказа пиццы.

```jsx
const pizzaSlice = createSlice({
  name: "pizza",
  initialState,
  reducers: {
    setItems(state, action) {
      state.items = action.payload;
    },
    getItems(state, action) {},
  },
  extraReducers: {
    [fetchPizza.pending]: (state) => {
      state.items = [];
      state.status = "loading";
    },
    [fetchPizza.fulfilled]: (state, action) => {
      state.items = action.payload;
      state.status = "success";
    },
    [fetchPizza.rejected]: (state) => {
      state.status = "error";
    },
  },
});
```

Теперь, мы можем импортировать асинхронную функцию в наши компоненты и использовать ее через `dispatch()`.