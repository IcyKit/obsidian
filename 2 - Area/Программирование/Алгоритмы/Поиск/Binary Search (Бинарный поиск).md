# Binary Search (Бинарный поиск)

Чтобы выполнить данный алгоритм, массив с данными должен быть предварительно отсортирован!

Этот алгоритм можно реализовать как с помощью цикла, так и с помощью рекурсии

Для начала нам нужно инициализировать центральную позицию массива, которую мы позже будем определять внутри цикла, потому что центральная позиция будет меняться после того, как мы будем исключать левую или правую часть массива.

Чтобы его получить, нам нужно знать начальную и конечную позицию массива.

Кроме этого нам понадобится переменная `found`, которая дает нам понять, найден элемент массива или нет, и переменная с позицией элемента. По дефолту: -1

```ts
let start = 0;
let end = arr.length
let middle;
let found = false;
let position = -1;
```

Далее, мы добавляем цикл, который будет работать, пока элемент не найден **И** позиция начального меньше или равна позиции конечного элемента массива.

В начале каждого цикла мы присваиваем `middle` позицию центрального элемента массива.

Далее мы сравниваем средний элемент с числом, которое мы ищем. Если центральное число равно числу, которое мы ищем, то мы устанавливаем `found` в `true`, соответственно, следующей итерации уже не будет, а также присваиваем переменной позиции - позицию среднего элемента массива и возвращаем ее.

Если же числа не равны, то мы сравниваем их на больше/меньше. Если число которое мы ищем меньше центрального элемента, то мы отсекаем правую часть, так как она нам уже не нужна. А если число больше - отсекаем левую часть.

И так цикл будет идти, пока он не найдет число или пока массив не станет длинной в 1 элемент.

```ts
while (found === false && start <= end) {
	middle = Math.floor((start + end) / 2); // Центральный элемент
	if (array[middle] === item) {
		found = true;
		position = middle;
		return position;
	}
	if (item < array[middle]) {
		end = middle - 1;
	} else if (item > array[middle]) {
		start = middle + 1;
	}
}
```

В итоге у нас получается:

```ts
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];

const binarySearch = (arr, item) => {
	let start = 0;
	let end = arr.length;
	let middle;
	let found = false;
	let position = -1;

	while (found === false && start <= end) {
		middle = Math.floor((start + end) / 2);
		if (arr[middle] === item) {
			found = true;
			position = middle;
			return position;
		}
		if (item < arr[middle]) {
			end = middle - 1;
		} else {
			start = middle + 1;
		}
	}
	return position;
}
```