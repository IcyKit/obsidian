# Breadth-first search (Обход в ширину)

Данный алгоритм использует метод очередь - FIFO (First In First Out), при таком методе из массива удаляются элементы с начала, а добавляются в конец. Можно провести аналогию с магазином. Кто первый встал на кассу, тот первый и выйдет.

Данный алгоритм применяется к графам. Он ищет, есть ли дорога через точки от точки старта, до точки конца.

И для начала нам нужно сделать этот граф. Он делается в виде объекта, где ключ объекта - точка, а значение - массив с точками, с которыми есть связь от этой точки.

Искать путь мы будем от точки А до точки G.

Для графа, который на картинке, объект будет выглядеть вот так:

```ts
const graph = {
  a: ["b", "c"],
  b: ["f"],
  c: ["d", "e"],
  d: ["f"],
  e: ["f"],
  f: ["g"],
};
```

Теперь можем приступать к написанию функции.

Параметрами функция должна принимать сам граф, точку начала, и до какой точки хотим найти путь.

Внутри функции создаем массив очереди обхода по графу и добавляем в него первый элемент.

Затем создаем цикл `while` в котором цикл будет проходиться, пока длина массива очереди больше 0. Используем именно `while`, потому что в ходе обхода графа, наш массив очереди будет пополняться.

В цикле мы инициализируем переменную. Ее значение будет равно первому удаленному элементу массива. **ИМЕННО ПЕРВОМУ!** Так как у нас используется метод очередь.

Далее мы делаем проверку, обращаясь к графу. Если у графа с ключем текущего значения итерации нет значения, то этому ключу мы присваиваем пустой массив, что означает, что из этой точки путей нет.

Следующая проверка - на наличие у графа с текущем элементом точки, которую мы ищем, если такая там имеется, то мы возвращаем true и цикл дальше не идет.

Если же это условие не сработало, то мы должны присвоить переменной очереди новое значение. Новое значение - развернутый массив очереди (т.е. весь массив очереди который был до этого) и элементы массива текущего элемента итерации.

```tsx
const graph = {
  a: ["b", "c"],
  b: ["f"],
  c: ["d", "e"],
  d: ["f"],
  e: ["f"],
  f: ["g"],
};

const breadthSearch = (graph, start, end) => {
  let queue = []; // Переменная очереди
  queue.push(start);
  while (queue.length > 0) {
    const current = queue.shift(); // Удаляем из очереди первый элемент и присваиваем его значение переменной
    if (!graph[current]) {
      graph[current] = []; // Если у графа с ключем текущего элемента нет значения,
			// то мы присваиваем ему значение пустого массива.
    }
    if (graph[current].includes(end)) {
      return true; // Если у графа с ключем текущего элемента есть точка,
			// которую мы ищем, то завершаем работу цикла и возвращаем true
    } else {
      queue = [...queue, ...graph[current]]; // В ином случае добавляем в очередь																						 
// помимо существующей очереди, значения из массива текущего элемента
// т.е. из ключа a добавятся в очередь b и c.
    }
  }
	return false; // Если ничего не нашлось - возвращаем false
};
```